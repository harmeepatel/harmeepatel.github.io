package components;

import (
	"bytes"
	"errors"
	"fmt"
	"harmeepatel.dev/web/icons"
	"log"
	"os"
	"os/exec"
	"slices"
	"strconv"
	"strings"
)

func AppendToFile(path string, str string) {
	f, err := os.OpenFile(path, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	if _, err = f.WriteString(str); err != nil {
		panic(err)
	}
}

func CreatFileIfNotExist(path string) {
	if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {
		if _, err := os.Create(path); err != nil {
			panic("trouble creating pygment_langs file")
		}
	}
}

func GetHighlighted(code string, lexer string) string {
	// create file if dosen't exist
	pygment_langs_path := "./web/pygment_langs"
	CreatFileIfNotExist(pygment_langs_path)

	highlight_path := "./static/css/highlight.css"
	CreatFileIfNotExist(highlight_path)

	// html gen
	theme := "one-dark"
	pygmentize := exec.Command("pygmentize", "-l", lexer, "-f", "html", "-O", "style="+theme)
	pygmentize.Stdin = bytes.NewBufferString(code)

	var out bytes.Buffer
	pygmentize.Stdout = &out

	if err := pygmentize.Run(); err != nil {
		log.Fatal("trouble colorizing code for: " + lexer)
	}

	var cleanHtml string
	cleanHtml = strings.Replace(out.String(), `<div class="highlight">`, ``, 1)
	cleanHtml = strings.Replace(cleanHtml, `</div>`, ``, 1)
	cleanHtml = strings.Replace(cleanHtml, `<pre>`, fmt.Sprintf(`<pre class="%s overflow-scroll"><code>`, lexer), 1)
	cleanHtml = strings.Replace(cleanHtml, `</pre>`, `</code></pre>`, 1)

	// css gen
	renderFlag := false
	pygment_langs, err := os.ReadFile(pygment_langs_path)
	if err != nil {
		log.Fatal("trouble reading ./web/pygment_langs file: ", err)
	}

	if !slices.Contains(strings.Split(string(pygment_langs), "\n"), lexer) {
		AppendToFile(pygment_langs_path, lexer+"\n")
		renderFlag = true
	}

	if renderFlag {
		var outCss bytes.Buffer
		pygmentizeCss := exec.Command("pygmentize", "-S", theme, "-f", "html", "-a", "."+lexer)
		pygmentizeCss.Stdout = &outCss

		if err := pygmentizeCss.Run(); err != nil {
			log.Fatal("trouble generating css for: "+lexer+" with err: ", err)
		}

		AppendToFile(highlight_path, outCss.String())

		renderFlag = false
	}
	return cleanHtml
}

var copyToClipboardHandle = templ.NewOnceHandle()
templ Code(lang string, fileName string, code string) {
	{{ highlight_code := GetHighlighted(code, lang) }}
    @copyToClipboardHandle.Once(){
        <script>
const scaleUp = "!animate-scale-up";
const scaleDown = "!animate-scale-down";
function addUp(classList, time) {
    const timer = setTimeout(() => {
        classList.add(scaleUp);
        clearTimeout(timer);
    }, time)
}
function addDown(classList, time) {
    const timer = setTimeout(() => {
        classList.add(scaleDown);
        clearTimeout(timer);
    }, time)
}
function removeUp(classList, time) {
    const timer = setTimeout(() => {
        classList.remove(scaleUp);
        clearTimeout(timer);
    }, time)
}
function removeDown(classList, time) {
    const timer = setTimeout(() => {
        classList.remove(scaleDown);
        clearTimeout(timer);
    }, time)
}
function copyToClipboard(self, code) {
    navigator.clipboard.writeText(code);
    const clipboard = self.querySelector(`[alt="Clipboard icon"]`);
    const checkmark = self.querySelector(`[alt="CheckInCircle icon"]`);

    var time = +window.getComputedStyle(document.body).getPropertyValue("--duration-copy-to-clipboard");
    const holdTime = time/4;

    addUp(checkmark.classList, time);
    addDown(clipboard.classList, time);


    setTimeout(() => {
        addUp(clipboard.classList, time * 4);
        addDown(checkmark.classList, time * 4);

        removeUp(checkmark.classList, time * 4);
        removeDown(clipboard.classList, time * 4);
    }, holdTime);

    removeUp(clipboard.classList, time * 6);
    removeDown(checkmark.classList, time * 6);
}
        </script>
    }
	<div class="rounded-xl">
		<div class="rounded-xl xl:rounded-2xl p-1.5 text-sm inset-ring inset-ring-dark/20 dark:inset-ring-light/20 !bg-code">
			<div class="px-3 pt-0.5 pb-1.5 flex items-center">
				if fileName != "" {
					<span class="font-mono text-base text-black dark:text-light"> { fileName } </span>
				}
				<button class="flex items-center ml-auto relative" onclick={ templ.JSFuncCall("copyToClipboard", templ.JSExpression("this"), code) }>
					@icons.Clipboard( 20, "w-full opacity-80 hover:opacity-100", "Clipboard icon")
					@icons.CheckInCircle( 20, "w-full !opacity-100 absolute left-0 scale-0", "CheckInCircle icon")
				</button>
			</div>
			<div class="overflow-scroll *:px-3 *:py-1.5 *:md:px-6 *:md:py-3 rounded-lg xl:rounded-xl *:!bg-light dark:*:!bg-dark">
				@templ.Raw(highlight_code)
			</div>
		</div>
	</div>
}

templ InlineCode(text string) {
	<code class={ "px-1 py-[1px] md:py-0.5 !font-mono md:text-[0.92rem] bg-black/10 dark:bg-white/10 border border-dark/50 dark:border-light/50 rounded-sm xl:rounded" }>
    {text}
    {children...}
    </code>&nbsp;
}

// icon
type IconInfo struct {
	Src   string
	Width int
	Class string
	Alt   string
}

templ Icon(icon IconInfo) {
	<img
		class={ "dark:filter dark:invert inline " + icon.Class }
		src={ icon.Src }
		alt={ icon.Alt }
		width={ strconv.Itoa(icon.Width) }
	/>
}
