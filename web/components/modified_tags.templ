package components;

import (
	"bytes"
	"errors"
	"fmt"
	"log"
	"os"
	"os/exec"
	"slices"
	"strconv"
	"strings"
)

func AppendToFile(path string, str string) {
	f, err := os.OpenFile(path, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	if _, err = f.WriteString(str); err != nil {
		panic(err)
	}
}

func CreatFileIfNotExist(path string) {
	if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {
		if _, err := os.Create(path); err != nil {
			panic("trouble creating pygment_langs file")
		}
	}
}

func GetHighlighted(code string, lexer string) string {
	// create file if dosen't exist
	pygment_langs_path := "./web/pygment_langs"
	CreatFileIfNotExist(pygment_langs_path)

	highlight_path := "./static/css/highlight.css"
	CreatFileIfNotExist(highlight_path)

	// html gen
	theme := "one-dark"
	pygmentize := exec.Command("pygmentize", "-l", lexer, "-f", "html", "-O", "style="+theme)
	pygmentize.Stdin = bytes.NewBufferString(code)

	var out bytes.Buffer
	pygmentize.Stdout = &out

	if err := pygmentize.Run(); err != nil {
		log.Fatal("trouble colorizing code for: " + lexer)
	}

	var cleanHtml string
	cleanHtml = strings.Replace(out.String(), `<div class="highlight">`, ``, 1)
	cleanHtml = strings.Replace(cleanHtml, `</div>`, ``, 1)
	cleanHtml = strings.Replace(cleanHtml, `<pre>`, fmt.Sprintf(`<pre class="%s"><code>`, lexer), 1)
	cleanHtml = strings.Replace(cleanHtml, `</pre>`, `</code></pre>`, 1)

	// css gen
	renderFlag := false
	pygment_langs, err := os.ReadFile(pygment_langs_path)
	if err != nil {
		log.Fatal("trouble reading ./web/pygment_langs file: ", err)
	}

	if !slices.Contains(strings.Split(string(pygment_langs), "\n"), lexer) {
		AppendToFile(pygment_langs_path, lexer+"\n")
		renderFlag = true
	}

	if renderFlag {
		var outCss bytes.Buffer
		pygmentizeCss := exec.Command("pygmentize", "-S", theme, "-f", "html", "-a", "."+lexer)
		pygmentizeCss.Stdout = &outCss

		if err := pygmentizeCss.Run(); err != nil {
			log.Fatal("trouble generating css for: "+lexer+" with err: ", err)
		}

		AppendToFile(highlight_path, outCss.String())

		renderFlag = false
	}
	return cleanHtml
}

templ Code(lang string, code string) {
	{{ highlight_code := GetHighlighted(code, lang) }}
	@templ.Raw(highlight_code)
}

templ InlineCode(text string) {
	<kbd class={ "px-1 py-[1px] md:py-0.5 font-mono md:text-[0.92rem] bg-black/10 dark:bg-white/10 border border-dark/50 dark:border-light/50 rounded-xs xl:rounded-sm" }>{ text }</kbd>&nbsp;
}

// icon
type IconInfo struct {
	Src   string
	Width int
	Class string
	Alt   string
}

templ Icon(icon IconInfo) {
	<img
		class={ "dark:filter dark:invert inline " + icon.Class }
		src={ icon.Src }
		alt={ icon.Alt }
		width={ strconv.Itoa(icon.Width) }
	/>
}
